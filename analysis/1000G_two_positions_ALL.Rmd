---
title: "1000G_two_positions_ALL"
author: "Andy Beck"
date: "2021-11-01"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(tikzDevice)

source("code/two_pos_new.R")

# latex plot options
width = 4
height = 4
```

# 1000G Two Position Models

## Preface: Shared Code

```{r}
#' Get contingency table for two positions
#'
#' @param population 1KGP superpopulation code
#' @param subtype Basic mutation subtype
#' @param p1 First relative position
#' @param p2 Second relative position
#' @param data_dir Location of count tables
#' @return Count table
singleton_count_2pos <- function(population, subtype, p1, p2,
                                 data_dir = "/net/snowwhite/home/beckandy/research/1000G_LSCI/output/all_count_2_pos/"){
  f_name <- paste0(data_dir, population, "/", subtype, "_p", p1, "_q", p2, ".csv")
  df <- read_csv(f_name, col_types = cols()) %>%
    filter(singletons > 0)
  df_tab <- xtabs(singletons ~ p1 + p2, data = df)
  return(df_tab)
}

#' Perform statistical test for singleton counts stratified by nucleotides at two flanking positions
#' @param population 1KGP superpopulation code
#' @param subtype Simple mutation subtype
#' @param stat_func Function to get statistic for pair of positions
#' @return Data.frame with statistics at each pair of positions
stat_pair_all <- function(population, subtype, stat_func, r_start=1, ...){
  final <- data.frame(p1 = numeric(),
                      p2 = numeric(),
                      statistic = numeric())
  for(i in c(-10:-1,r_start:9)){
    for(j in (i+1):10){
      if(j == 0) next
      if(j == 1 & r_start > 1) next
      stat_val <- stat_func(population, subtype, i, j, ...)
      final <- bind_rows(final, data.frame(p1 = i,
                                           p2 = j,
                                           statistic = stat_val))
    }
  }
  return(final)
}

#' Heatmap plot for two-position statistics
#' 
#' @param population 1KGP super-population code
#' @param subtype Simple mutation subtype
#' @param statistic_function Function which returns data frame with statistic at pairs of positions
#' @param plot_title Text to begin plot title
#' @param fill_label Legend title
#' @return Figure with statistic values at each pair of positions
heatmap_plot <- function(population, subtype, 
                         statistic_function, plot_title, fill_label, r_start = 1, ...){
  df <- stat_pair_all(population, subtype, statistic_function, r_start, ...)
  
  if(!str_starts(subtype, "cpg")){
    subtype2 <- str_replace(subtype, "_", " -> ")
  } else {
    subtype <- str_sub(subtype, 5)
    subtype2 <- paste0("(cpg) ", str_replace(subtype, "_", " -> "))
  }
  
  p <- df %>%
    ggplot(aes(x = p2, y = p1, fill = statistic)) +
    geom_tile() +
    ggtitle(paste0(plot_title, subtype2),
            paste0("Population: ", population,
                   "; Min: ", round(min(df$statistic), 2), 
                   "; Max: ", round(max(df$statistic), 2)))+
    xlab("Relative Position 2") +
    ylab("Relative Position 1") +
    labs(fill = fill_label) +
    scale_fill_distiller(palette = "Reds", direction = 1)
  return(p)
}
```


## Introduction

In a [previous document](1000G_single_position_ALL.html) we evaluated the influence of individual positions on the mutation rate as a function of relative position. In do this we marginalized over the nucleotides at other positions, ignoring any potential interaction effect. Here in this document we will being to explore the extent to which interactions among flanking positions influence the rate of substitution at a focal site by first focusing on two-way interactions. 

Challenges we face here are:

1. We know that the marginal distributions at single positions in our control samples (and the genome-wide background rate) don't match corresponding marginals in the singletons
2. When considering the 2-way contingency table at each pair of positions, the row and column marginals don't predict the observed 4x4 cells in the genome-wide and control counts (i.e. the nucleotides at the two positions are not independent)

## Chi-Square Test of Independence

For this analysis we'll be looking at only our singleton counts. For each sub type at each pair of positions we observe a 4x4 2-way contingency table. Performing a chi square test of independence asks if we have evidence to reject the null hypothesis that the two "variables" (sites) are independent; i.e. the number of times we see AA is the product of the row marginal for A and the column marginal for A, etc. 

This may seem like a silly thing to do since we already know genome-wide the rate of di-nucleotides is not predicted by the product of the frequency of the two nucleotides. It is in fact the case that this pattern is also observed in the singleton counts, and nothing here is probably worth mentioning in the paper. But anyways, here are those results.


### AT_CG

```{r echo=FALSE, warning=FALSE}
p <- chi_sq_ind_plot("ALL", "AT_CG")
p
```

We see here the expected pattern that directly adjacent di-nucloetides are not observed at frequencies suggested by the product of their marginal frequencies, even when looking only at those seen flanking a singleton. Might I eventually want to look at a version of this that isn't heavily affected by the large sample size? Maybe.

### AT_GC

```{r echo=FALSE, warning=FALSE}
chi_sq_ind_plot("ALL", "AT_GC")
```

### AT_TA

```{r echo=FALSE, warning=FALSE}
chi_sq_ind_plot("ALL", "AT_TA")
```

### GC_AT

```{r echo=FALSE, warning=FALSE}
chi_sq_ind_plot("ALL", "GC_AT")
```

### cpg_GC_AT

```{r echo=FALSE, warning=FALSE}
chi_sq_ind_plot("ALL", "cpg_GC_AT")
```

### GC_TA

```{r echo=FALSE, warning=FALSE}
chi_sq_ind_plot("ALL", "GC_TA")
```

### cpg_GC_TA

```{r echo=FALSE, warning=FALSE}
chi_sq_ind_plot("ALL", "cpg_GC_TA")
```

## Goodness of Fit: Estimate Distribution with Controls

The idea here is to estimate the frequency of flanking dimers using the dimers we observe flanking control positions. This ignores the fact that the distribution of individual flanking nucleotides has already been shown to differ between the singletons and the matched controls; what I think we want is a way to test for an interaction while accounting for the different individual marginals.


### AT_CG

```{r}
subtype <- "AT_CG"
p <- chi_sq_re_plot("ALL", subtype)
print(p)
```

### AT_GC

```{r}
subtype <- "AT_GC"
p <- chi_sq_re_plot("ALL", subtype)
print(p)
```

### AT_TA

```{r}
subtype <- "AT_TA"
p <- chi_sq_re_plot("ALL", subtype)
print(p)
```

### GC_AT

```{r}
subtype <- "GC_AT"
p <- chi_sq_re_plot("ALL", subtype)
print(p)
```

### cpg_GC_AT

```{r}
subtype <- "cpg_GC_AT"
p <- chi_sq_re_plot("ALL", subtype)
print(p)
```

### GC_TA

```{r}
subtype <- "GC_TA"
p <- chi_sq_re_plot("ALL", subtype)
print(p)
```

### cpg_GC_TA

```{r}
subtype <- "cpg_GC_TA"
p <- chi_sq_re_plot("ALL", subtype)
print(p)
```

### GC_CG

```{r}
subtype <- "GC_CG"
p <- chi_sq_re_plot("ALL", subtype)
print(p)
```

### cpg_GC_CG

```{r}
subtype <- "cpg_GC_CG"
p <- chi_sq_re_plot("ALL", subtype)
print(p)
```

## GOF: Control interaction estimation

An idea I want to try here is to try and estimate a shared interaction parameter using only the control frequencies and apply this to the singleton frequencies. In a nutshell, we can think of the 16 frequencies we see in the control table as being the product of two marginal frequencies and an additional interaction term (question: should this be additive or multiplicative?). In the multiplicative formulation of the interaction, the frequency in each cell can be written as:

$$
f^C_{i,j} = p^C_{i.}p^C_{.j}p_{ij}
$$

and the idea here would be to estimate the $p_{ij}$ interaction terms using the controls and using these to adjust the cell frequencies in the singletons and then assess the fit using a $\chi^2$ goodness of fit test.

### AT_CG

```{r}
subtype <- "AT_GC"
p <- control_mult_int_plot("ALL", subtype, type = "re")
print(p)
```

### AT_GC

```{r}
subtype <- "AT_GC"
p <- control_mult_int_plot("ALL", subtype, type = "re")
print(p)
```

### AT_TA

```{r}
subtype <- "AT_TA"
p <- control_mult_int_plot("ALL", subtype, type = "re")
print(p)
```

### GC_AT

```{r}
subtype <- "GC_AT"
p <- control_mult_int_plot("ALL", subtype, type = "re")
print(p)
```

### cpg_GC_AT

```{r}
subtype <- "cpg_GC_AT"
p <- control_mult_int_plot("ALL", subtype, type = "re")
print(p)
```


### GC_TA

```{r}
subtype <- "GC_TA"
p <- control_mult_int_plot("ALL", subtype, type = "re")
print(p)
```

### cpg_GC_TA

```{r}
subtype <- "cpg_GC_TA"
p <- control_mult_int_plot("ALL", subtype, type = "re")
print(p)
```

### GC_CG

```{r}
subtype <- "GC_CG"
p <- control_mult_int_plot("ALL", subtype, type = "re")
print(p)
```

### cpg_GC_CG

```{r}
subtype <- "cpg_GC_CG"
p <- control_mult_int_plot("ALL", subtype, type = "re")
print(p)
```

## Loglinear Models

The above analyses told us that, in general, the joint distribution of the cell counts in the 4x4 contingency table was not the product of the row and column marginals. This is unsurprising since we see this exact same pattern in both the genome-wide counts and the control counts. That is, it is already well-known that genome-wide occurrence of dinucleotides is not predicted by the product of the frequencies of the individual nucleotides, so it's no surprise we see an interaction in our singletons. But is the interaction we see in the singletons the same that we observe in the controls? That question can be addressed using the log-linear modeling framework employed by Zhu et al (2017). Here, we'll fit a model of the counts for both the singletons and the controls, allowing for each to have their own marginal distributions at each position, but the interaction between the two positions is shared. We then use the deviance statistic to compare the fit of this model to the fully saturated model which allows for different interaction terms between the singletons and the controls.

### AT_CG

```{r echo=FALSE}
deviance_plot("ALL", "AT_CG")

deviance_re_plot("ALL", "AT_CG")
```

### AT_GC

```{r echo=FALSE}
deviance_plot("ALL", "AT_GC")

deviance_re_plot("ALL", "AT_GC")
```

### AT_TA

```{r echo=FALSE}
deviance_plot("ALL", "AT_TA")

deviance_re_plot("ALL", "AT_TA")
```

### GC_AT

```{r echo=FALSE}
deviance_plot("ALL", "GC_AT")

deviance_re_plot("ALL", "GC_AT")
```

### cpg_GC_AT

```{r echo=FALSE}
deviance_plot("ALL", "cpg_GC_AT", r_start = 2)

deviance_re_plot("ALL", "cpg_GC_AT", r_start = 2)
```

### GC_TA

```{r echo=FALSE}
deviance_plot("ALL", "GC_TA")

deviance_re_plot("ALL", "GC_TA")
```

### cpg_GC_TA

```{r echo=FALSE}
deviance_plot("ALL", "cpg_GC_TA", r_start = 2)

deviance_re_plot("ALL", "cpg_GC_TA", r_start = 2)
```

### GC_CG

```{r echo=FALSE}
deviance_plot("ALL", "GC_CG")

deviance_re_plot("ALL", "GC_CG")
```

### cpg_GC_CG

```{r echo=FALSE}
deviance_plot("ALL", "cpg_GC_CG", r_start = 2)

deviance_re_plot("ALL", "cpg_GC_CG", r_start = 2)
```

## Di-nucleotide Residuals

Similar to what we investigated in the single model case, here we look into each pair of position's deviance/RE result and break it down into the contributions from each pair of nucleotides. Here we have a challenge that we did not have in the single position case: for each pair of nucleotides we have two residuals: one for the fitted singleton value, and the other for the fitted control count. While they are both used to calculate the overall statistic for the position, for this first approach I am only going to look at the dinucleotide residuals for the singleton fitted values. This is because I find this case to be more straightforward in regards to assigning a sign and interpreting (i.e., do we observe more XY in the singletons than expected? etc.)

As an example let's look at the residuals for the A>G sub type at the -2, -1 positions:

```{r}
get_residuals_re("AT_GC", "ALL", -2, -1) %>%
  knitr::kable()
```

Here we see that among the two position influences the biggest difference between the singleton and the control distributions was for the CA dinucleotide; this is the same as what Zhu et al (2017) observed at this position for this sub type.  Let's take a look at what happens if we summarize each pair of positions by the sum of the two re/deviance residuals instead of just ignoring the control residual.

Here again we see that the top contribution for any dinucleotide pair is CT at the -2, -1 positions when we account for both the singleton and the control residuals:

```{r}
get_residuals_re2("AT_GC", "ALL", -2, -1) %>%
  knitr::kable()
```

Perhaps we'd like to visualize these results in a heatmap?

```{r}
heatmap_signed_re_res("AT_GC", "ALL", -2, -1)
```

## Alternative Di-nucleotide Residuals

### RE Contribution (Control Intercept Estimation)

In the analysis above where we used the control samples to estimate the interaction and then adjusted marginal products using this interaction, we computed the relative entropy between our observed singleton distribution and the expectation under marginal independence adjusted by control interaction as our measure of influence. This statistic is the sum of expected logarithmic differences for each cell in the 4x4 table, and we will look at these individual values to assess at each pair of positions which di-nucleotides were either over or under-represented. We can also look at values for individual nucleotides at one position summed over the nucleotides at the other position (not sure how this would be interpreted, to be honest).

So, again returning to the example of -2, -1 in AT_GC:

```{r}
plot_control_mult_res("ALL", "AT_GC", -2, -1)
```

