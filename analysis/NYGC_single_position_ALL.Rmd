---
title: "NYGC_single_position_ALL"
author: "Andy Beck"
date: "2023-05-23"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(patchwork)
#library(tikzDevice)
#library(sjPlot)
width = 4
height = 4

## Plot options
theme_set(theme_bw())
plot_w <- 800
plot_h <- 500
plot_dpi <- 300

cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#000000")
```

# 1000G Single Position Models - All 

## Introduction

Here in this document we present the results for the single position models using the singletons from all 2,504 unrelated individuals in the 1000G deep sequence data from the NYGC.

### Model Descriptions

### Log Linear Model Approach

Following the example of Zhu et al (2017), we also construct models of the form

$$
\log(n_{ij}) = \lambda_0 + \sum_{k \in \{C,G,T\}} \lambda_j I(i=k) + \lambda_{s}I(j=s)
$$

where we jointly model the counts for singletons and their matched controls stratified by the nucleotides at a given flanking position in the +/- 10 bp window. Note that here the model assumes a shared nucleotide distribution between the singletons and the controls; allowing for a difference through an interaction term would yield a fully saturated model. Zhu et al (2017) use the deviance statistic to identify putative mutation motifs, which compares the above reduced model to the fully saturated model, with a larger deviance statistic resulting from a larger difference between the observed distribution of nucleotides flanking singleton and control sites from the fitted distribution based on the reduced model. The deviance statistic tends to increase due to sample size, so Zhu et al (2017) additionally divided the deviance statistic by twice the sample size to yield the relative entropy/KL divergence, which is not sensitive to sample size and allowed for comparisons between mutation sub types. We choose to take a similar approach in that we compute the KL divergence between the observed and fitted frequencies for only the singletons.

## 9 Subtype Results

The nine basic subtypes are AT_CG, AT_GC, AT_TA, GC_AT, GC_TA, GC_CG, cpg_GC_AT, cpg_GC_TA, and cpg_GC_CG, where the notation XY_JK indicates we either observed a X>J or Y>K substitution, with XY and JK being complementary to each other. For each sub-type with reference alleles XY and position i within a 21-mer window centered at the singleton, we model the distributions of nucleotides A, C, G and T flanking the singletons using the rates we observe either genome-wide flanking the reference nucleotides XY at the same relative position or the rates of nucleotides flanking control positions sampled for each singleton. We use the chi-square goodness of fit statistic to "measure" the degree to which this model doesn't hold. First, let's plot the deviance statistics we observe at each relative position for each sub-type.

### Code for loading results

```{r}
read_subtype_pop_res <- function(pop, subtype, data_dir = "/net/snowwhite/home/beckandy/research/1000G_NYGC_LSCI/output/single_pos/"){
  fname <- paste0(data_dir, pop, "/", subtype, ".csv")
  df <- read_csv(fname, show_col_types = FALSE) %>%
    rowwise() %>%
    mutate(re = dev / (2 * (singletons + controls)))
  return(df)
}

read_pop_res <- function(pop, data_dir = "/net/snowwhite/home/beckandy/research/1000G_NYGC_LSCI/output/single_pos/"){
  df <- read_subtype_pop_res(pop, "AT_CG", data_dir = data_dir)
  df$subtype <- "AT_CG"
  for(st in c("AT_GC", "AT_TA", 
              "GC_AT", "GC_TA", "GC_CG",
              "cpg_GC_AT", "cpg_GC_TA", "cpg_GC_CG") ) {
    df2 <- read_subtype_pop_res(pop, st, data_dir = data_dir)
    df2$subtype <- st
    df <- bind_rows(df, df2)
  }
  return(df)
}
```

### All subtypes plot options

```{r}
df <- read_pop_res("ALL")

df %>%
  filter(abs(offset) < 10) %>%
  ggplot(aes(x = offset, y = re, color = subtype)) +
  geom_point() + 
  geom_line() +
  scale_color_manual(values = cbPalette) +
  xlab("Relative Position") +
  ylab("Relative Entropy") +
  labs(color = "Subtype")
```

Separate plots for A>N and C>N

```{r}
df %>%
  filter(abs(offset) < 10,
         str_starts(subtype, "AT")) %>%
  ggplot(aes(x = offset, y = re, color = subtype)) +
  geom_point() + 
  geom_line() +
  scale_color_manual(values = cbPalette) +
  xlab("Relative Position") +
  ylab("Relative Entropy") +
  labs(color = "Subtype") +
  theme_bw()
```

```{r}
df %>%
  filter(abs(offset) < 10,
         !str_starts(subtype, "AT")) %>%
  ggplot(aes(x = offset, y = re, color = subtype)) +
  geom_point() + 
  geom_line() +
  scale_color_manual(values = cbPalette) +
  xlab("Relative Position") +
  ylab("Relative Entropy") +
  labs(color = "Subtype") +
  theme_bw()
```

Patwork the plots together:

```{r}
p1 <- df %>%
  filter(abs(offset) < 10,
         str_starts(subtype, "AT")) %>%
  ggplot(aes(x = offset, y = re, color = subtype)) +
  geom_point() + 
  geom_line() +
  scale_color_manual(values = cbPalette) +
  xlab("Relative Position") +
  ylab("Relative Entropy") +
  labs(color = "Subtype")
  
p2 <- df %>%
  filter(abs(offset) < 10,
         !str_starts(subtype, "AT")) %>%
  ggplot(aes(x = offset, y = re, color = subtype)) +
  geom_point() + 
  geom_line() +
  scale_color_manual(values = cbPalette) +
  xlab("Relative Position") +
  ylab("Relative Entropy") +
  labs(color = "Subtype")

p_combined <- p1 + p2

p_ranges_y <- c(ggplot_build(p_combined[[1]])$layout$panel_scales_y[[1]]$range$range,
                ggplot_build(p_combined[[2]])$layout$panel_scales_y[[1]]$range$range)
p_combined & 
  ylim(min(p_ranges_y), max(p_ranges_y)) & theme_bw()
```

